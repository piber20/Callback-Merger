---------------------
-- CALLBACK MERGER --
---------------------
-- Version 5
-- Created by piber

-- This script merges all the callbacks registered by mods into a single one for each callback type and extra variable, possibly improving performance, but more importantly, fixing callbacks that wouldn't let later callbacks work.
-- It also fixes a few bugs and implements a few QOL changes to the callbacks

-- Overrides 'Isaac.RegisterMod'. Compatibility may be sketchy but could still work.

-- CallbackMerger.RegisteredMods
-- table
-- A table of registered mods that Callback Merger knows about.
-- Used when comparing origin mods of callbacks and to pass it into callback args
-- Indexed by order of discovery

-- CallbackMerger.Callbacks
-- table
-- Contains all the callbacks that were registered, indexed by callback id
-- Callback data = {mod reference, function, extra variable}
-- Callback Merger calls from this, comparing the included values

-- CallbackMerger.CondensedCallbacks
-- table
-- Contains Callback Merger's main callbacks, which call all other callbacks of the same type
-- Indexed by callback id, then indexed by extra variable.

-- CallbackMerger.CallbackReturnFilters
-- table
-- Used to determine if returning true or false in certain callbacks would be treated the same as if they returned nil.
-- Indexed by callback id, set to one of these:
--	0 = ignore all
--	1 = dont ignore anything
--	2 = ignore true for returning
--	3 = ignore false for returning

-- CallbackMerger.CallbackReturnPreventions
-- table
-- Used to determine if returning certain values would prevent later callbacks from being called
-- Indexed by callback id, set to one of these:
-- 0 = returning anything prevents later callbacks
-- 1 = later callbacks happen regardless of what returns
-- 2 = true prevents later callbacks
-- 3 = false prevents later callbacks

-- CallbackMerger.CallbackReturnToArg
-- table
-- Used to determine what callbacks would have their return values passed into the next callback
-- Indexed by callback id, values can be:
--	number = corresponds to the arg to replace with previous callbacks' return values for later callbacks
--	table  = will replace multiple args using number values from replaced tables at those indexes

-- CallbackMerger.RegisterMod - Overrides Isaac.RegisterMod
-- function(table mod, string mod name, number api version)
-- No return value
-- Used to store the mods which have been registered, this is done to handle the merged callbacks.
-- Overrides Isaac.RegisterMod, call CallbackMerger.OldRegisterMod for the unmodified RegisterMod function.

-- CallbackMerger.AddCallback - Overrides Isaac.AddCallback
-- function(table mod, number callback id, function, extra variable)
-- No return value
-- Extends AddCallback, this is done to handle the merged callbacks.
-- Overrides Isaac.AddCallback, call CallbackMerger.OldAddCallback for the unmodified AddCallback function.

-- CallbackMerger.RemoveCallback - Overrides Isaac.RemoveCallback
-- function(table mod, number callback id, function)
-- No return value
-- Extends RemoveCallback, this is done to handle the merged callbacks.
-- Overrides Isaac.RemoveCallback, call CallbackMerger.OldRemoveCallback for the unmodified RemoveCallback function.

------------------------------------------------------------------------------
--                   IMPORTANT:  DO NOT EDIT THIS FILE!!!                   --
------------------------------------------------------------------------------
-- This file relies on other versions of itself being the same.             --
-- If you need something in this file changed, please let the creator know! --
------------------------------------------------------------------------------

-- CODE STARTS BELOW --


-------------
-- version --
-------------
local fileVersion = 5

--prevent older/same version versions of this script from loading
if CallbackMerger and CallbackMerger.Version >= fileVersion then

	return CallbackMerger

end

local recreateCondensedCallbacks = false
if not CallbackMerger then

	CallbackMerger = {}
	CallbackMerger.Version = fileVersion
	
elseif CallbackMerger.Version < fileVersion then

	local oldVersion = CallbackMerger.Version
	
	-- handle old versions
	if oldVersion < 5 then
	
		--replace the condensed callbacks functions with new ones if some were created
		if #CallbackMerger.CondensedCallbacks > 0 then
			recreateCondensedCallbacks = true
		end
		
	end

	CallbackMerger.Version = fileVersion

end


-----------
-- setup --
-----------
CallbackMerger.Mod = CallbackMerger.Mod or RegisterMod("Callback Merger", 1)


----------------------------
-- callback type handling --
----------------------------

--CallbackMerger.CallbackReturnFilters--
-- 0 = ignore all
-- 1 = dont ignore anything
-- 2 = ignore true for returning
-- 3 = ignore false for returning
CallbackMerger.CallbackReturnFilters = CallbackMerger.CallbackReturnFilters or {}

CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_USE_ITEM] = 3

--these callbacks can only be used once in the base game
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_FAMILIAR_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_NPC_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PLAYER_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PICKUP_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_TEAR_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PROJECTILE_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_KNIFE_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_BOMB_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_NPC_UPDATE] = 3
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_SPAWN_CLEAN_AWARD] = 3


--CallbackMerger.CallbackReturnPreventions--
-- 0 = later callbacks happen regardless of what returns
-- 1 = returning anything prevents later callbacks
-- 2 = true prevents later callbacks
-- 3 = false prevents later callbacks
CallbackMerger.CallbackReturnPreventions = CallbackMerger.CallbackReturnPreventions or {}
	
CallbackMerger.CallbackReturnPreventions[ModCallbacks.MC_ENTITY_TAKE_DMG] = 3
CallbackMerger.CallbackReturnPreventions[ModCallbacks.MC_PRE_USE_ITEM] = 2
CallbackMerger.CallbackReturnPreventions[ModCallbacks.MC_PRE_NPC_UPDATE] = 2
CallbackMerger.CallbackReturnPreventions[ModCallbacks.MC_PRE_SPAWN_CLEAN_AWARD] = 2

--these callbacks can only be used once in the base game, we're going to make it so returning nil allows later callbacks
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_FAMILIAR_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_NPC_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PLAYER_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PICKUP_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_TEAR_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_PROJECTILE_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_KNIFE_COLLISION] = 1
CallbackMerger.CallbackReturnFilters[ModCallbacks.MC_PRE_BOMB_COLLISION] = 1


--CallbackMerger.CallbackReturnToArg--
-- number corresponds to the arg to replace with previous callbacks' return values for later callbacks
-- table containing numbers will replace multiple args using values from replaced tables at those indexes
CallbackMerger.CallbackReturnToArg = CallbackMerger.CallbackReturnToArg or {}

CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_POST_CURSE_EVAL] = 1 --return value is the curse bitmask
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_POST_PICKUP_SELECTION] = {2,3} --return values are entity variant and subtype

--these callbacks only let the first return do something in the base game
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_PRE_ENTITY_SPAWN] = {1,2,3,7} --return values are entity type, variant, subtype, and seed
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_PRE_ROOM_ENTITY_SPAWN] = {1,2,3} --return values are entity type, variant, and subtype

--these callbacks dont do this in the base game
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_GET_CARD] = 2 --return value is card id
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_POST_GET_COLLECTIBLE] = 1 --return value is item id
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_GET_PILL_EFFECT] = 1 --return value is pill effect id
CallbackMerger.CallbackReturnToArg[ModCallbacks.MC_GET_TRINKET] = 1 --return value is trinket id


-----------------
-- registermod --
-----------------
CallbackMerger.RegisteredMods = CallbackMerger.RegisteredMods or {}
CallbackMerger.Callbacks = CallbackMerger.Callbacks or {}
CallbackMerger.CondensedCallbacks = CallbackMerger.CondensedCallbacks or {}

--override RegisterMod to catch registered mods
CallbackMerger.OldRegisterMod = CallbackMerger.OldRegisterMod or Isaac.RegisterMod
function CallbackMerger.RegisterMod(mod, modname, apiversion)
	
	--call the old register mod function
	--pcall to catch any errors
	local modRegistered, returned = pcall(CallbackMerger.OldRegisterMod, mod, modname, apiversion)
	
	--erroring
	if not modRegistered then
	
		returned = string.gsub(returned, "callbackmerger.OldRegisterMod", "RegisterMod")
		error(returned, 2)
		
	end
	
	if type(mod) == "table" then
	
		--check if the mod is already in the table
		local modAlreadyRegistered = false
		for i=1, #CallbackMerger.RegisteredMods do
			
			if CallbackMerger.RegisteredMods[i] == mod then
				modAlreadyRegistered = true
				break
			end
			
		end
		
		--add mod to registered mods table
		if not modAlreadyRegistered then
			CallbackMerger.RegisteredMods[#CallbackMerger.RegisteredMods+1] = mod
		end
	
	end
	
end
Isaac.RegisterMod = CallbackMerger.RegisterMod

-----------------
-- addcallback --
-----------------
--override AddCallback to handle merging of callbacks
CallbackMerger.OldAddCallback = CallbackMerger.OldAddCallback or Isaac.AddCallback
function CallbackMerger.CreateMergedCallback(callbackId, extraVar)

	CallbackMerger.CondensedCallbacks[callbackId] = CallbackMerger.CondensedCallbacks[callbackId] or {}
	
	local functionExistedAlready = false
	if CallbackMerger.CondensedCallbacks[callbackId][extraVar] then
		functionExistedAlready = true
	end

	CallbackMerger.CondensedCallbacks[callbackId][extraVar] = function(_, ...)
	
		local args = {...}
		local toReturn = nil
		
		local ignoreTrueReturn = false
		local ignoreFalseReturn = false
		
		local returnAtTrueReturn = false
		local returnAtFalseReturn = false
		
		if CallbackMerger.CallbackReturnFilters[callbackId] then
		
			-- 0 = ignore all
			-- 1 = dont ignore anything
			-- 2 = ignore true for returning
			-- 3 = ignore false for returning
			ignoreTrueReturn = CallbackMerger.CallbackReturnFilters[callbackId] == 0 or CallbackMerger.CallbackReturnFilters[callbackId] == 2
			ignoreFalseReturn = CallbackMerger.CallbackReturnFilters[callbackId] == 0 or CallbackMerger.CallbackReturnFilters[callbackId] == 3
		
		end
		
		if CallbackMerger.CallbackReturnPreventions[callbackId] then
		
			-- 0 = later callbacks happen regardless of what returns
			-- 1 = returning anything prevents later callbacks
			-- 2 = true prevents later callbacks
			-- 3 = false prevents later callbacks
			returnAtTrueReturn = CallbackMerger.CallbackReturnPreventions[callbackId] == 1 or CallbackMerger.CallbackReturnPreventions[callbackId] == 2
			returnAtFalseReturn = CallbackMerger.CallbackReturnPreventions[callbackId] == 1 or CallbackMerger.CallbackReturnPreventions[callbackId] == 3
		
		end
		
		local returnToArg = CallbackMerger.CallbackReturnToArg[callbackId]
	
		if CallbackMerger.Callbacks[callbackId] then
		
			for _, callbackData in ipairs(CallbackMerger.Callbacks[callbackId]) do
			
				local dataMod = callbackData[1]
				local dataFunction = callbackData[2]
				local dataExtraVar = callbackData[3]
			
				if extraVar == dataExtraVar then
		
					--pcall to catch any errors
					local noErrors, returned = pcall(dataFunction, dataMod, table.unpack(args))
					
					if not noErrors then
					
						error("[" .. tostring(dataMod.Name) .. "] " .. returned, 2)
					
					--callback passed with no errors
					elseif type(returned) ~= "nil" then
					
						local doReturn = true
						
						if type(returned) == "boolean" then
							
							--ignore true if we should
							if returned and ignoreTrueReturn then
								doReturn = false
							end
							
							--ignore false if we should
							if not returned and ignoreFalseReturn then
								doReturn = false
							end
							
						end
					
						if doReturn then
						
							toReturn = returned
							
							--set the args to values which were returned
							if returnToArg then
							
								if type(returnToArg) == "number" and type(returned) == "number" then
									args[returnToArg] = returned
								end
							
								if type(returnToArg) == "table" and type(returned) == "table" then
								
									for _,argindex in ipairs(returnToArg) do
									
										if returned[argindex] then
											args[argindex] = returned[argindex]
										end
										
									end
									
								end
								
							end
							
							--prevent later callbacks from happening if we should
							if (toReturn == true and returnAtTrueReturn == true)
							or (toReturn == false and returnAtFalseReturn == true) then
								
								break
								
							end
							
						end
						
					end
					
				end
			
			end
			
		end
		
		return toReturn
	
	end
	
	if not functionExistedAlready then
	
		CallbackMerger.OldAddCallback(CallbackMerger.Mod, callbackId, CallbackMerger.CondensedCallbacks[callbackId][extraVar], extraVar)
		
	end

end

function CallbackMerger.AddCallback(mod, callbackId, fn, extraVar)
	
	--force undefined/non-number extra vars to -1
	if type(extraVar) ~= "number" then
	
		extraVar = -1
		
	end

	--error if no callback id was provided
	if type(callbackId) ~= "number" then
	
		error("bad argument #2 to 'AddCallback' (number expected, got " .. type(callbackId) .. ")", 2)
		
	end
	
	--error if no function was provided
	if type(fn) ~= "function" then
	
		error("bad argument #3 to 'AddCallback' (function expected, got " .. type(fn) .. ")", 2)
		
	end

	--check if the mod is already in the table
	local modAlreadyRegistered = false
	for i=1, #CallbackMerger.RegisteredMods do
		
		if CallbackMerger.RegisteredMods[i] == mod then
			modAlreadyRegistered = true
			break
		end
		
	end
	
	--add mod to registered mods table
	if not modAlreadyRegistered then
		CallbackMerger.RegisteredMods[#CallbackMerger.RegisteredMods+1] = mod
	end

	--add the callback to the callbacks table
	CallbackMerger.Callbacks[callbackId] = CallbackMerger.Callbacks[callbackId] or {}
	table.insert(CallbackMerger.Callbacks[callbackId], {mod, fn, extraVar})
	
	--create a callback for the callback merger mod if it doesnt already exist
	CallbackMerger.CondensedCallbacks[callbackId] = CallbackMerger.CondensedCallbacks[callbackId] or {}
	if not CallbackMerger.CondensedCallbacks[callbackId][extraVar] then
	
		CallbackMerger.CreateMergedCallback(callbackId, extraVar)
		
	end

end
Isaac.AddCallback = CallbackMerger.AddCallback


--------------------
-- removecallback --
--------------------
--override RemoveCallback to handle removing of merged callbacks
CallbackMerger.OldRemoveCallback = CallbackMerger.OldRemoveCallback or Isaac.RemoveCallback
function CallbackMerger.RemoveCallback(mod, callbackId, fn)
	
	--error if no callback id was provided
	if type(callbackId) ~= "number" then
	
		error("bad argument #2 to 'RemoveCallback' (number expected, got " .. type(callbackId) .. ")", 2)
		
	end
	
	--error if no function was provided
	if type(fn) ~= "function" then
	
		error("bad argument #3 to 'RemoveCallback' (function expected, got " .. type(fn) .. ")", 2)
		
	end
	
	--remove the callback from the callbacks table
	if CallbackMerger.Callbacks[callbackId] then
	
		for i=#CallbackMerger.Callbacks[callbackId], 1, -1 do
		
			local callbackData = CallbackMerger.Callbacks[callbackId][i]
			
			if callbackData[1] == mod and callbackData[2] == fn then
			
				table.remove(CallbackMerger.Callbacks[callbackId], i)
			
			end
			
		end
		
	end

end
Isaac.RemoveCallback = CallbackMerger.RemoveCallback

------------------------
-- old version compat --
------------------------
if recreateCondensedCallbacks then
	
	for callbackId, _ in pairs(CallbackMerger.CondensedCallbacks) do
	
		CallbackMerger.CondensedCallbacks[callbackId] = CallbackMerger.CondensedCallbacks[callbackId] or {}
		
		for extraVar, _ in pairs(CallbackMerger.CondensedCallbacks[callbackId]) do
			print(tostring(callbackId) .. " " .. tostring(extraVar))
			CallbackMerger.CreateMergedCallback(callbackId, extraVar)
			
		end
		
	end
	
end

------------
-- return --
------------
return CallbackMerger
