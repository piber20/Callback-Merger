---------------------
-- CALLBACK MERGER --
---------------------
-- Version 1
-- Created by piber

-- This script merges all the callbacks registered by mods into a single one for each callback type and extra variable, possibly improving performance, but more importantly, fixing callbacks that wouldn't let later callbacks work.
-- It also fixes a few bugs and implements a few QOL changes to the callbacks

-- Overrides 'Isaac.RegisterMod'. Compatibility may be sketchy but could still work.

-- CallbackMerger.RegisteredMods
-- table
-- A table of registered mods that Callback Merger knows about.
-- Used when comparing origin mods of callbacks and to pass it into callback args
-- Indexed by order of discovery

-- CallbackMerger.Callbacks
-- table
-- Contains all the callbacks that were registered, indexed by callback id
-- Callback data = {mod reference, function, extra variable}
-- Callback Merger calls from this, comparing the included values

-- CallbackMerger.CondensedCallbacks
-- table
-- Contains Callback Merger's main callbacks, which call all other callbacks of the same type
-- Indexed by callback id, then indexed by extra variable.

-- CallbackMerger.CallbackReturnFilters
-- table
-- Used to determine if returning true or false in certain callbacks would be treated the same as if they returned nil.
-- Indexed by callback id, set to one of these:
--	0 = ignore all
--	1 = dont ignore anything
--	2 = ignore true for returning
--	3 = ignore false for returning

-- CallbackMerger.CallbackReturnToArg
-- table
-- Used to determine what callbacks would have their return values passed into the next callback
-- Indexed by callback id, values can be:
--	number = corresponds to the arg to replace with previous callbacks' return values for later callbacks
--	table  = will replace multiple args using number values from replaced tables at those indexes

-- CallbackMerger.RegisterMod - Overrides Isaac.RegisterMod
-- function(table mod, string mod name, number api version)
-- No return value
-- Used to extend the AddCallback and RemoveCallback functions of mods when Isaac.RegisterMod is called, this is done to handle the merged callbacks.
-- Overrides Isaac.RegisterMod, call CallbackMerger.OldRegisterMod for the unmodified RegisterMod function.

------------------------------------------------------------------------------
--                   IMPORTANT:  DO NOT EDIT THIS FILE!!!                   --
------------------------------------------------------------------------------
-- This file relies on other versions of itself being the same.             --
-- If you need something in this file changed, please let the creator know! --
------------------------------------------------------------------------------

-- CODE STARTS BELOW --


-------------
-- version --
-------------
local fileVersion = 1

--prevent older/same version versions of this script from loading
if CallbackMerger and CallbackMerger.Version >= fileVersion then

	return CallbackMerger

end

if not CallbackMerger then

	CallbackMerger = {}
	CallbackMerger.Version = fileVersion
	
elseif CallbackMerger.Version < fileVersion then

	local oldVersion = CallbackMerger.Version
	
	--handle old versions
	--nothing yet, cause no old versions yet

	CallbackMerger.Version = fileVersion

end


-----------
-- setup --
-----------
CallbackMerger.Mod = CallbackMerger.Mod or RegisterMod("Callback Merger", 1)


----------------------------
-- callback type handling --
----------------------------
-- 0 = ignore all
-- 1 = dont ignore anything
-- 2 = ignore true for returning
-- 3 = ignore false for returning
CallbackMerger.CallbackReturnFilters = {

	[ModCallbacks.MC_USE_ITEM] = 3,

	--these callbacks can only be used once in the base game
	[ModCallbacks.MC_PRE_FAMILIAR_COLLISION] = 1,
	[ModCallbacks.MC_PRE_NPC_COLLISION] = 1,
	[ModCallbacks.MC_PRE_PLAYER_COLLISION] = 1,
	[ModCallbacks.MC_PRE_PICKUP_COLLISION] = 1,
	[ModCallbacks.MC_PRE_TEAR_COLLISION] = 1,
	[ModCallbacks.MC_PRE_PROJECTILE_COLLISION] = 1,
	[ModCallbacks.MC_PRE_KNIFE_COLLISION] = 1,
	[ModCallbacks.MC_PRE_BOMB_COLLISION] = 1,
	[ModCallbacks.MC_PRE_NPC_UPDATE] = 3,
	[ModCallbacks.MC_PRE_SPAWN_CLEAN_AWARD] = 3,
	
	--once one of these callbacks return, later callbacks never get called in the base game
	[ModCallbacks.MC_ENTITY_TAKE_DMG] = 2,
	[ModCallbacks.MC_PRE_USE_ITEM] = 3
	
}

-- number corresponds to the arg to replace with previous callbacks' return values for later callbacks
-- table containing numbers will replace multiple args using values from replaced tables at those indexes
CallbackMerger.CallbackReturnToArg = {

	[ModCallbacks.MC_POST_CURSE_EVAL] = 1, --return value is the curse bitmask
	[ModCallbacks.MC_POST_PICKUP_SELECTION] = {2,3}, --return values are entity variant and subtype
	
	--these callbacks only let the first return do something in the base game
	[ModCallbacks.MC_PRE_ENTITY_SPAWN] = {1,2,3,7}, --return values are entity type, variant, subtype, and seed
	[ModCallbacks.MC_PRE_ROOM_ENTITY_SPAWN] = {1,2,3}, --return values are entity type, variant, and subtype
	
	--these callbacks dont do this in the base game
	[ModCallbacks.MC_GET_CARD] = 2, --return value is card id
	[ModCallbacks.MC_POST_GET_COLLECTIBLE] = 1, --return value is item id
	[ModCallbacks.MC_GET_PILL_EFFECT] = 1, --return value is pill effect id
	[ModCallbacks.MC_GET_TRINKET] = 1 --return value is trinket id
	
}


-----------------
-- registermod --
-----------------
CallbackMerger.RegisteredMods = CallbackMerger.RegisteredMods or {}
CallbackMerger.Callbacks = CallbackMerger.Callbacks or {}
CallbackMerger.CondensedCallbacks = CallbackMerger.CondensedCallbacks or {}

--override RegisterMod to handle merging of callbacks
CallbackMerger.OldRegisterMod = CallbackMerger.OldRegisterMod or Isaac.RegisterMod
function CallbackMerger.RegisterMod(mod, modname, apiversion)
	
	--call the old register mod function
	--pcall to catch any errors
	local modRegistered, returned = pcall(CallbackMerger.OldRegisterMod, mod, modname, apiversion)
	
	--proper erroring, gives actual useful line
	if not modRegistered then
	
		returned = string.gsub(returned, "callbackmerger.OldRegisterMod", "RegisterMod")
		error(returned, 2)
		
	end
	
	if type(mod) == "table" then
		
		--add mod to registered mods table
		CallbackMerger.RegisteredMods[#CallbackMerger.RegisteredMods+1] = mod
		
		
		-----------------
		-- addcallback --
		-----------------
		--extend AddCallback:
		--  make absolute sure the extra var is a number
		--	proper erroring
		--	add callbacks added to callbacks table
		--	handle condensing of callbacks
		mod.AddCallback = function(self, callbackId, fn, extraVar)
			
			--force undefined/non-number extra vars to -1
			if type(extraVar) ~= "number" then
			
				extraVar = -1
				
			end
		
			--error if no callback id was provided
			if type(callbackId) ~= "number" then
			
				error("bad argument #2 to 'AddCallback' (number expected, got " .. type(callbackId) .. ")", 2)
				
			end
			
			--error if no function was provided
			if type(fn) ~= "function" then
			
				error("bad argument #3 to 'AddCallback' (function expected, got " .. type(fn) .. ")", 2)
				
			end
			
			--add the callback to the callbacks table
			CallbackMerger.Callbacks[callbackId] = CallbackMerger.Callbacks[callbackId] or {}
			table.insert(CallbackMerger.Callbacks[callbackId], {self, fn, extraVar})
			
			--create a callback for the callback merger mod if it doesnt already exist
			CallbackMerger.CondensedCallbacks[callbackId] = CallbackMerger.CondensedCallbacks[callbackId] or {}
			if not CallbackMerger.CondensedCallbacks[callbackId][extraVar] then
			
				CallbackMerger.CondensedCallbacks[callbackId][extraVar] = function(_, ...)
				
					local args = {...}
					local toReturn = nil
					
					local ignoreTrueReturn = false
					local ignoreFalseReturn = false
					
					if CallbackMerger.CallbackReturnFilters[callbackId] then
					
						-- 0 = ignore all
						-- 1 = dont ignore anything
						-- 2 = ignore true for returning
						-- 3 = ignore false for returning
						if CallbackMerger.CallbackReturnFilters[callbackId] == 0 then
							ignoreTrueReturn = true
							ignoreFalseReturn = true
						elseif CallbackMerger.CallbackReturnFilters[callbackId] == 1 then
							ignoreTrueReturn = false
							ignoreFalseReturn = false
						elseif CallbackMerger.CallbackReturnFilters[callbackId] == 2 then
							ignoreTrueReturn = true
							ignoreFalseReturn = false
						elseif CallbackMerger.CallbackReturnFilters[callbackId] == 3 then
							ignoreTrueReturn = false
							ignoreFalseReturn = true
						end
					
					end
					
					local returnToArg = CallbackMerger.CallbackReturnToArg[callbackId]
				
					if CallbackMerger.Callbacks[callbackId] then
					
						for _, callbackData in ipairs(CallbackMerger.Callbacks[callbackId]) do
						
							local dataMod = callbackData[1]
							local dataFunction = callbackData[2]
							local dataExtraVar = callbackData[3]
						
							if extraVar == dataExtraVar then
							
								for _, registeredMod in ipairs(CallbackMerger.RegisteredMods) do
								
									if registeredMod == dataMod then
							
										local returned = dataFunction(registeredMod, table.unpack(args))
										
										if type(returned) ~= "nil" then
										
											local doReturn = true
											
											if type(returned) == "boolean" then
												
												--ignore true if we should
												if returned and ignoreTrueReturn then
													doReturn = false
												end
												
												--ignore false if we should
												if not returned and ignoreFalseReturn then
													doReturn = false
												end
												
											end
										
											if doReturn then
											
												toReturn = returned
												
												--set the args to values which were returned
												if returnToArg then
												
													if type(returnToArg) == "number" and type(returned) == "number" then
														args[returnToArg] = returned
													end
												
													if type(returnToArg) == "table" and type(returned) == "table" then
													
														for _,argindex in ipairs(returnToArg) do
														
															if returned[argindex] then
																args[argindex] = returned[argindex]
															end
															
														end
														
													end
													
												end
												
											end
											
										end
									
									end
							
								end
								
							end
						
						end
						
					end
					
					return toReturn
				
				end
				
				Isaac.AddCallback(CallbackMerger.Mod, callbackId, CallbackMerger.CondensedCallbacks[callbackId][extraVar], extraVar)
				
			end
			
		end
		
		
		--------------------
		-- removecallback --
		--------------------
		--extend RemoveCallback:
		--	proper erroring
		--	remove callbacks added to callbacks table
		--	handle condensing of callbacks
		mod.RemoveCallback = function(self, callbackId, fn)
			
			--error if no callback id was provided
			if type(callbackId) ~= "number" then
			
				error("bad argument #2 to 'RemoveCallback' (number expected, got " .. type(callbackId) .. ")", 2)
				
			end
			
			--error if no function was provided
			if type(fn) ~= "function" then
			
				error("bad argument #3 to 'RemoveCallback' (function expected, got " .. type(fn) .. ")", 2)
				
			end
			
			--remove the callback from the callbacks table
			if CallbackMerger.Callbacks[callbackId] then
			
				for i=#CallbackMerger.Callbacks[callbackId], 1, -1 do
				
					local callbackData = CallbackMerger.Callbacks[callbackId][i]
					
					if callbackData[1] == self and callbackData[2] == fn then
					
						table.remove(CallbackMerger.Callbacks[callbackId], i)
					
					end
					
				end
				
			end
			
		end
	
	end
	
end
Isaac.RegisterMod = CallbackMerger.RegisterMod
